[{"title":"基于Fatfree和Knockout的前后端分离的开发模式(1)","date":"2017-09-18T04:23:28.000Z","path":"基于Fatfree和Knockout的前后端分离的开发模式（1）/","text":"近几年，与前端相关的技术变革的很快，从Ajax技术的兴起，到现在比较流行的三大前端框架(Angular.js、react.js、vue.js)，从MVC到MVVM到设计模式，前端的技术与思想有了革命性的发展。 近期在整理技术栈时，觉得这个方法是一套成熟的开发模式，虽然可能有点过时，但是还是整理出来分享给大家，相互间学习。 1 设计模式1.1 MVC MVC设计模式是指模型—视图—控制器三层的设计框架，Model主要进行数据的操作，View主要完成UI界面的绘制和与用户的交互，Controller主要是从视图里面读取数据，并像模型发送数据写入到数据库。 mvc设计模式是最常见的设计模式，在这不进行说明，在下面的MVVM章节针对这个开发模式进行详细的说明。 1.2 MVVM MVVM（Model-View-ViewModel)是在MVC(Model-View-Control)模式之后引出的新的开发模式，他与MVC模式一样用于把视图（界面）和数据进行解耦，不同的是采用ViewModel来完成数据与视图的双向绑定，通过自动化的方式承担大部分数据工作，来解决由于界面复杂化和快速迭代带来的问题。 MVVM是MVC设计模式的升级，更多的是前端来提MVVM的设计模式的一个概念，前端通过Ajax技术来获取数据。API提供的数据的Json的格式，然后通过Model模块将数据进行解析，ViewModel将View与Model进行绑定，用户访问View。 后端还是会采用传统的MVC的设计模式，API提供Json数据格式的数据。同时在该开发流程中，页面的路由和API的路由都是通过后端来控制的，这跟目前比较流行的前端路由存在着差别。 2 后端2.1 Web框架在这个开发模式中，使用的Web框架为Fatfree，这是一个轻量的Web框架，但是提供的功能比较齐全。包括了路由模块，数据库模块，支持多种数据库，包括Mysql，Sqlite，MongoDB等等。 2.1.1 路由Fatfree有两种路由的写法，一种是写到配置文件，一种是直接写到程序的入口函数中。 1234567$f3 = require('path/to/base.php');$f3 = route('GET /', function()&#123; echo 'hello,world!'; &#125;);$f3 -&gt; run; 这个程序是一个最基本的Hello World的程序，就是将路由写到了程序入口的函数中。通过GET的方法来请求／路由，得到一个’hello,world!’的界面。 还有一种通过配置文件的方式来定义路由： 1$f3-&gt;config('app/config/routes.ini'); 然后在配置文件添加路由： 12[routes]GET / = IndexController-&gt;index 通过GET的方法来请求/路由，通过IndexController类里面的index方法来返回结果。 2.1.2 数据库 对象关系映射（英语：(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换[1] 。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 fatfree提供了\\DB\\SQL\\Mapper的ORM类，里面包含了数据库基本的增删改查，能够提供基本的功能。 链接数据库： 1$mapper = new \\DB\\SQL\\Mapper(\\DB\\SQL $db, string $table [, array|string $fields = NULL [, int $ttl = 60 ]] ) 如果你想把其写成Model库，可以按照下面的方法写： 12345678910$f3-&gt;set('DB',new DB\\SQL('sqlite:db/database.sqlite'));class User extends \\DB\\SQL\\Mapper &#123; public function __construct() &#123; parent::__construct( \\Base::instance()-&gt;get('DB'), 'users' ); &#125;&#125;$user = new User();$user-&gt;load('id = 1'); 查寻数据： 123456//load()方法$user-&gt;load(array(\"id\",1));//findone()方法$user-&gt;findone(array(\"id\",1));//find()方法$user-&gt;find(array(\"id\",1)) 添加数据或修改数据： 123456789$user = new User();$user-&gt;id = 2;$user-&gt;save();// save()函数比较智能，若是数据存在则会对数据进行修改$user = new User();$user-&gt;load('id = 1');$user-&gt;id = 2;$user-&gt;save(); 删除数据： 123$user = new User();$user-&gt;load('id = 1');$user-&gt;erase(); 2.1.3 PHP包管理工具 Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 “packages” 和 “libraries”，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。 Composer的具体安装和使用在这里就不做具体的说明了，需要学习的话网上有很多的教程。 composer.json可以如下进行配置： 12345678910111213&#123; \"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" &#125; &#125;, \"require\":&#123; \"robmorgan/phinx\":\"*\", \"bcosca/fatfree\": \"3.3.0\" &#125;, \"require-dev\": &#123;&#125;&#125; 里面的Phinx是数据库迁移的工具，fatfree是我们使用的web框架。 1234# composer没有全局安装php composer.phar install# composer全局安装composer install 安装成功后会自动生成vendor目录，文件目录的组织方式是vendor／项目所有人名／项目名。例如：vendor/robmorgan/phinx。 2.1.4 数据库迁移工具数据库迁移工具的目的主要是使得开发人员在开发环境和线上环境进行统一，减少了程序员手动对数据库进行修改。 在这个开发模式中，我们选择了Phinx作为数据库迁移的工具。通过composer我们已经把phinx安装成功了。 12# 初始化项目，会在文件中添加一个db/migrations文件夹php vendor/bin/phinx init 添加表 1php vendor/bin/phinx create MyNewMigration 执行上面的命令会在生成的文件目录下面新建一个YYYYMMDDHHMMSS_my_new_migration.php文件。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpuse Phinx\\Migration\\AbstractMigration;class CreateUserLoginsTable extends AbstractMigration&#123; /** * Change Method. * * More information on this method is available here: * http://docs.phinx.org/en/latest/migrations.html#the-change-method * * Uncomment this method if you would like to use it. */ public function change() &#123; $table = $this-&gt;table('user_logins'); $table-&gt;addColumn('user_id', 'integer') -&gt;addColumn('created', 'datetime') -&gt;create(); &#125; /** * Migrate Up. */ public function up() &#123; $this-&gt;execute(\"CREATE TABLE `users` (`name` varchar(64) NOT NULL DEFAULT '',`passwords` varchar(255) NOT NULL DEFAULT '',`id` INT NOT NULL auto_increment PRIMARY KEY,`leave` INT NOT NULL DEFAULT 1) ENGINE=InnoDB DEFAULT CHARSET=utf8;\"); &#125; /** * Migrate Down. */ public function down() &#123; $this-&gt;execute(\"DROP TABLE `users`;\"); &#125;&#125; 生成的文件中可以包含三个方法，一个是新建，一个是修改，一个是删除。方法里面可以使用ORM的方法，但是也可以写SQL语句。 命令： 12345# 迁移phinx migrate#回退 phinx rollback -e development -t 20120103083322 配置： 在init后，phinx在生成目录的时间同时也会生成一个phinx.yml文件，里面可以把数据库的配置文件写到里面。 12345678910111213paths: migrations: %%PHINX_CONFIG_DIR%%/db/migrationsenvironments: default_migration_table: phinxlog default_database: development development: adapter: mysql host: 127.0.0.1 name: user: pass: port: 3306 charset: utf8","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"go语言中使用反射函数代替switch语法","date":"2017-07-30T03:49:45.000Z","path":"go语言中使用反射函数代替switch语法/","text":"近期在公司实习，参与了公司的一个分布式的应用服务系统。系统采用Golang语言作为系统的开发语言，在开发过程中采用了Go语言的反射函数的特性来取代了以前常使用的switch语法。 switch-case是一种多种选择的语法，其本质与if-else方法差不多，都是通过判断条件来执行不同的方法。而Go提供了一种机制在运行时更新变量和检查它们的值，调用它们的方法，和它们支持的内在操作，但是在编译时并不知道这些变量的类型。这种机制被称为反射，反射也可以让我们将类型本身作为第一类的值类型处理。 Web应用路由问题在我们编写Web应用过程中，常常会遇到一个路由需要对应一个方法，我们会选择使用switch的方法来进行路由的匹配，若是路由匹配成功，我们会调用一个方法，这种方法能够很简便的完成我们的工作，也便于程序员在编写代码过程中厘清思路。 问题： 在一个URL的路由中，我们在request中通过cmd的参数来对应一个方法，这样我们要如何根据一个cmd对应一个方法？ 可能针对这个问题有人会说，我们为什么不把cmd放到URL里面，这样的话就是一个方法对应一个路由，而且大多数的Web框架会通过回调函数来进行函数调用，针对于这个问题，我只能说大部分的都是将cmd放到http的request里面的，具体的好处可能就是减少了对API的监管，以及当路由比较多的时间能够减少麻烦吧。 用switch方法实现： 123456789cmd := this.GetString(\"cmd\")switch cmd&#123; case \"ls\": ls() case \"cd\": cd() default: fmt.Println(\"cmd method missing\")&#125; 上述的方法先通过URL的参数获取到cmd，然后通过cmd来调用相对应的方法。在传统的MVC的设计模式中，需要在Controller中添加switch方法，同时需要在Model中实现相对应的方法，总计修改了2个文件。 go语言反射函数reflect包在reflect包中，主要通过Typeof()和Valueof()两个方法来实现反射。两个方法相互结合，能够反射出被反射函数的全部信息。 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"reflect\")type Ref struct &#123; id int name string&#125;func (ref *Ref)GetName()&#123; fmt.Println(\"getName()函数\")&#125;func (ref *Ref)GetNameById()&#123; fmt.Println(\"getNameById()函数\")&#125;func main()&#123; t := reflect.TypeOf(&amp;Ref&#123;&#125;) v := reflect.ValueOf(new(Ref)) fmt.Println(t) fmt.Println(v) for i:= 0; i&lt; t.NumMethod();i++&#123; fmt.Println(t.Method(i).Name) v.Method(i).Call(nil) &#125;&#125; TypeOf()TypeOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Type类型。 在上面的示例中，通过Method().Name能够反射其方法的函数名。 常用的方法： func (t *rtype)String() string func (t *rtype)Name() string func (t *rtype)Kind() reflect.kind func (t *rtype)Method(int) reflect.Method func (t *rtype)Elem() reflect.Type func (t *rtype)In(int) reflect.Type ValueOf()ValueOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Value类型。 在上面的示例中，通过Method().Call()能够反射出其函数并执行。 常用的方法： func (v Value)String() string func (v Value)Elem() reflect.Value func (v Value)Method(int) reflect.Value func (v Value)Call(in []Value) (r []Value) 反射的实现过程由于有反射的存在，因此在传统的MVC的设计模式中，当我们添加服务时，不需要修改Controller端的代码，Controller只需要维持一个map的表，里面的就来存储需要被反射的models。 123456789101112131415161718192021222324252627282930package server import( \"reflect\" \"fmt\")// ReServer 来保存map的结构体type ReServer struct &#123; m map[string]interface&#123;&#125;&#125;// RegisterService 注册服务func (this *ReServer)RegisterService(service interface&#123;&#125;)(err error)&#123; serviceType := reflect.TypeOf(service).Elem() ServiceName := serviceType.Name() if _,ok := this.m[ServiceName] if ok &#123; fmt.Println(\"service has been registered\") &#125;else&#123; this.m[ServiceName] = service &#125; return&#125;// Start 服务启动func (this *ReServer)Start()&#123; for k,v := range this.m &#123; // 里面根据业务逻辑执行想要的方法 &#125;&#125; 在上诉的例子中，通过对services的服务注册，就能够通过Start()函数发现服务，并且根据业务来实现自己的代码。 1234567891011121314151617181920package mainimport ( \"server\")type Server struct &#123;&#125;func (server *Server)funOne()&#123; fmt.Println(\"Server FunOne\")&#125; func main()&#123; reServer := &amp;server.ReServer&#123; m: make(map[string]interface&#123;&#125;) &#125; err := reServer.RegisterService(new(Server)) reServer.Start()&#125; 因此在我们主函数中，导入封装好的包，只需要注册一个结构体，就能够将自己的方法反射出来实现。 对应上面的Web的路由问题，我们将Controller进行封装，然后将Model进行反射，当我们业务增加时，我们在Model里面添加就可以了，不需要修改Controller。","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"openfalon监控配置","date":"2017-05-16T02:27:29.000Z","path":"openfalon监控配置/","text":"最进在看《docker 容器与容器云 第2版》，但是对于运维的一些知识还是不够了解，在同学的推荐下，尝试配置openfalon监控，监控自己写的软件，为以后需要开发的项目积累一点经验。 Open-falcon是小米运维团队从互联网公司的需求出发，根据多年的运维经验，结合SRE、SA、DEVS的使用经验和反馈，开发的一套面向互联网的企业级开源监控产品。 准备工作Open-falcon的开发语言是golang语言，创始人秦晓辉在谈为何选择golang语言时也有一定的说明：open-falcon编写的整个脑洞历程 源码安装123456#查看go语言环境go version#若没有安装go语言环境需要安装go语言sudo apt install golangecho &quot;export GOPATH=~/workspaces/go&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 安装Redis和mysql 12sudo apt install redis-serversudo apt install mysql-server 安装文件下载已经安装位置确定 123mkdir -p $GOPATH/src/github.com/open-falconcd $GOPATH/src/github.com/open-falcongit clone https://github.com/open-falcon/falcon-plus.git 导入数据库 123456cd $GOPATH/src/github.com/open-falcon/falcon-plus/scripts/mysql/db_schema/mysql -h 127.0.0.1 -u root -p &lt; uic-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; portal-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; graph-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; dashboard-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; alarms-db-schema.sql 安装，安装成功后会生成一个压缩包 123make allmake agentmake pack 解包和建立文件目录 1234export WorkDir=&quot;$HOME/open-falcon&quot;mkdir -p $WorkDirtar -xzvf open-falcon-vx.x.x.tar.gz -C $WorkDircd $WorkDir 数据库连接的配置格式是: username:password@tcp(path:port)/xxxx 安装web监控端dashboard下载dashboard源码 123export WorkDir=&quot;$HOME/open-falcon&quot;cd $WorkDirgit clone https://github.com/open-falcon/dashboard.git 下载安装依赖 12345678910sudo suapt-get install -y python-virtualenvapt-get install -y slapd ldap-utilsapt-get install -y libmysqld-devapt-get install -y build-essentialapt-get install -y python-dev libldap2-dev libsasl2-dev libssl-devcd dashboardsudo virtualenv ./env./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple 修改配置，dashboard的配置文件为config.py 123#添加数据库密码，默认为空PORTAL_DB_PASS = os.environ.get(\"PORTAL_DB_PASS\",\"123456\")ALARM_DB_PASS = os.environ.get(\"ALARM_DB_PASS\",\"123456\") 启动 1./control start","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"nodejs项目安装与部署","date":"2017-04-14T01:50:44.000Z","path":"nodejs项目安装与部署/","text":"nodejs安装： 1brew install node Backend后端代码部署nodejs后端web框架选择express Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 安装步骤： 1npm install -g express -g参数说明express是全局安装，express在4.0以后就将express的命令行工具分离出来了，需要独立安装。 1npm install -g express-generator 安装成功后就可以部署项目了，express主要是后端程序 1express -e backend 安装依赖 1npm install 启动后台程序 1npm start frontend前端代码部署项目前端框架选择vue Vue.js 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 1、安装步骤 1npm install -g vue 同样，vue的命令行工具也要单独安装： 12345678# 全局安装命令行工具npm install -g vue-cli# 创建项目vue init webpack frontend# 安装依赖并启动cd frontendnpm install npm run dev","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"王者荣耀挂机脚本初探（1）","date":"2017-04-07T07:08:22.000Z","path":"王者荣耀挂机脚本初探（1）/","text":"​ 最近和同学一起准备写一个王者荣耀的挂机程序，因此写一个文档把实验过程和实验过程中遇到的问题进行记录。 ​ 目前选择的是安卓微信平台，通过微信扫码登陆。 虚拟机的选择​ 在腾讯的王者荣耀的官方网站上有推荐的虚拟机，在尝试了不同的虚拟机后选择了逍遥游模拟器，优点：可以模拟按键、能够多开程序。 虚拟机端口查找​ 在选择好了虚拟机后，要尝试用adb连接到开的程序，但是现在是不知道程序运行的端口，因此要查询到程序运行的端口。 ​ 测试平台选择了windows10，因此在cmd命令行工具中输入命令，使用netstat -0命令扫描全部的端口。 在没有运行模拟器时发现端口，便于跟模拟器运行后的端口进行对比。运行模拟器： 根据上面的对比，大概猜测端口为21501、21503、21505、32799、32804、32807，尝试使用abd全部连接，然后根据连接情况进行判断。 可以进一步判断端口为21501、21503、21505。然后查看当前的运行的模拟器： 已经可以判断端口为21503。 模拟器多开端口查询·跟上诉的步骤相同： 可以观察出大致每添加一个模拟器，端口号增加10。 简单通过adb shell连接控制游戏 可以发现王者里面的英雄动了，第一步成功。 遇到问题 连接模拟器过多，解决方法：打开任务管理器，把adb.exe进程结束，然后重新连接。","tags":[{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"Hexo搭件个人博客","date":"2017-04-02T06:10:25.000Z","path":"Hexo搭件个人博客/","text":"​ 作为一个程序员，一开始还是希望有自己的个人博客，高中时，一个同学给了一个二级域名，然后让我自己来做这个博客，好像是用的WordPress，但是高中时期基本上不了解计算机技术，最终还是不了了之，后面大学买了属于自己的域名和服务器，里面搭件了两个博客，由于服务器是外网的，后台访问速度很慢，也就没有使用，因此选择了hexo和coding.net来搭件自己的博客。 hexo下载安装安装命令 ，-g参数是全局安装 1npm install -g hexo 在Coding.net上创建项目，并且克隆到本地 1git clone https://git.coding.net/flytutu/blog.git 初始化hexo并且安装依赖 12hexo initnpm install 本地预览hexo博客 12hexo ghexo s 然后在浏览器上面访问http://localhost:4000，可以看到hexo在浏览器上面的样子 hexo上传代码部署本地文件到coding.net，打开根目录_config.yml文件，在文件末尾添加： 1234deploy: type: gitrepository: https://git.coding.net/flytutu/blog.gitbranch: master 然后可以上传代码， 1hexo d 若上传报错，需要下载hexo-deployer-git模块 1npm install hexo-deployer-git --save Coding.net里面打开pages服务，然后将自己的域名绑定 域名绑定 新建界面，然后在文件source/_posts里面看到文件，然后可以修改 1hexo new &quot;文件名称&quot;","tags":[{"name":"闲谈","slug":"闲谈","permalink":"http://yoursite.com/tags/闲谈/"}]}]