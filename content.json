[{"title":"基于docker搭建nexus","date":"2018-12-23T10:50:23.000Z","path":"基于docker搭建nexus/","text":"Nexus是Maven仓库管理器，也可以叫Maven的私服。Nexus是一个强大的Maven仓库管理器，它极大地简化了自己内部仓库的维护和外部仓库的访问。利用Nexus你可以只在一个地方就能够完全控制访问和部署在你所维护仓库中的每个Artifact。Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。 1 下载并配置镜像 下载 1234docker pull sonatype/nexus3# 下载成功后可以查看镜像docker images 运行 12345# 新建数据卷docker volume create --name nexus-data# 运行docker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3 参数-d为后台运行，-p将容器8081端口转发到主机8081上，-v将数据卷持久化。 打开网页127.0.0.1:8081，进入nexus系统，系统有两个默认账号admin和anonymous，admin的密码为admin123，具有全部的权限，anonymous作为匿名用户，只具有查看权限。 2 配置仓库 pepositories name属性说明 maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar maven-releases：私库发行版jar maven-snapshots：私库快照（调试版本）jar maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。 pepositories type属性说明 group(仓库组类型)：又叫组仓库，用于方便开发人员自己设定的仓库 hosted(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库） proxy(代理类型)：从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的Configuration页签下Remote Storage Location属性的值即被代理的远程仓库的路径） virtual(虚拟类型)：虚拟仓库 2.1 修改maven全局文件settings.xml是针对全局所有项目的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;pluginGroups/&gt; &lt;proxies/&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-local&lt;/id&gt; &lt;name&gt;nexus repository&lt;/name&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus local&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus local&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/settings&gt; 配置生成后，通过mvn help:effective-settings命令 2.2 项目中配置pom.xml123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus local&lt;/id&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 3 上传包上传maven包前需要对项目的pom.xml文件进行修改 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 若需要上传源码，需要添加插件 12345678910111213141516&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.1 利用mvn deploy命令上传1mvn deploy -DskipTests 3.2 利用IDEA插件进行上传 选择deploy进行上传","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"配置DHCP服务器","date":"2018-10-10T07:59:19.000Z","path":"配置DHCP服务器/","text":"安装dhcp测试环境为Ubuntu15.04系统 安装如下： 1sudo apt-install dhcp3-server 在网上会看到出现两个包：dhcp3-server和isc-dhcp-server，实际上这两个包为同一个包，只是配置文件名称发生了差异（/etc/dhcp3 –&gt; /etc/dhcp），参考 配置dhcp安装了dhcp后并不能马上开启服务开始使用，必须要配置才能成功的开启服务。 要打开/etc/default/isc-dhcp-server并在里面选择你要使用的网卡: 1sudo vim /etc/default/isc-dhcp-server 选择了网卡后就要进行下一项。对你的/etc/dhcp/dhcpd.conf进行修改，我是直接在该文件里面进行添加。 1sudo vim /etc/dhcp/dhcpd.conf 配置就如下图: 给你的网卡固定一个ip。 1sudo vim/etc/network/interfaces 将你选择的网卡固定一个ip。这一步非常重要，很多人错误就是没有这一步。 开启服务。 1sudo /etc/init.d/isc-dhcp-server restart 在局域网的其他机器配置dhcp服务器为本机，然后查看IP。 错误当开启服务时，出现下面的错误。 解决方法：查看syslog。 1tail /var/log/syslog 在选择网卡时出现问题。","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"基于Fatfree和Knockout的前后端分离的开发模式(2)","date":"2017-10-09T10:16:51.000Z","path":"基于Fatfree和Knockout的前后端分离的开发模式（2）/","text":"上一篇文章整理了这个开发模式的后端与数据库迁移方面的东西，这篇文章接着上一篇文章对前端的JS框架进行详细的介绍，由于我更加偏重于后端，因此对于前端的了解不够深入，文章仅做参考，具体的使用请自行查询文档，若文章存在问题，忘指正，以便进行修改。 1、Jquery.js框架 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery框架的出现大大减少了使用原生的js进行开发的速度问题，极大的简便了开发者。其中主要是简便了dom元素的查找和操作。 选择器 开头符号：$() 元素选择器 ：$(‘p’) id选择器：$(‘#lab’) 类选择器：$(‘.lab’)\u0010\u0010 事件处理 on方法，能够绑定事 1234$().on(\"\",function()&#123; // \"\"中填写需要的时间 // 该处填写需要执行的事件&#125;); click 点击事件 123$().click(function()&#123; // 该处添加点击事件，其他的jquery方法可以类似的写&#125;); AJAX方法 ajax方法（包括post方法和get方法，可以选择） 1234567$.ajax(&#123; type: 'POST', // 选择方法 url: url, // 上传URL地址 data: data, // 提交数据 success: success, // 请求成功后回调的函数 dataType: dataType // 预期服务器返回数据类型&#125;); post方法 123456$.post( url, data, success(data, textStatus, jqXHR), dataType); get方法 123456$.get( url, data, success(response,status,xhr), dataType); 2、Require.js框架 require.js的诞生，就是为了解决这两个问题： ​ （1）实现js文件的异步加载，避免网页失去响应； ​ （2）管理模块之间的依赖性，便于代码的编写和维护。 现在，越来越多的js框架，并且js框架之间相互依赖，当依赖关系很复杂的时候，代码的编写和维护会变得更加困难。Require框架就是为解决着这些问题。 js加载 添加js文件在js目录，直接加载 1&lt;script src=\"js/require.js\"&gt;&lt;/script&gt; 异步加载 1&lt;script src=\"js/require.js\" defer async=\"true\" &gt;&lt;/script&gt; 加载页面js文件 1&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt; 当很多js文件，且依赖文件相同，可以简化，导入一次配置就可以了 123&lt;script src=\"js/require.js\"&gt;&lt;/script&gt;&lt;script src=\"js/config.js\"&gt;&lt;/script&gt;&lt;script src=\"js/main.js\"&gt;&lt;/script&gt; 主模块 使用AMD规范定义的的require()函数。 1234// main.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here&#125;); 例如： 123require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); js文件加载会先加载jquery、underscore、backbone，再运行回调函数。 模块加载 针对依赖的问题，我们需要对模块的加载进行自己定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 3、Knockout.js Knockout是一款很优秀的JavaScript库，它可以帮助你仅使用一个清晰整洁的底层数据模型（data model）即可创建一个富文本且具有良好的显示和编辑功能的用户界面。任何时候你的局部UI内容需要自动更新（比如：依赖于用户行为的改变或者外部的数据源发生变化），KO都可以很简单的帮你实现，并且非常易于维护。 我们使用Knockout来做数据的双向绑定，主要使用data-bind在View上进行数据绑定。 建立数据模型 在MVVM的设计模式中，View Model是很重要的一环，通过使用KO建立一个View Model，需要声明一个JS对象。例如： 1var people = &#123;name: 'xiaoming', age: '12'&#125; 激活对象 data-bind属性并不是HTML固有对象，但使用它是完全正确的（这是完全遵守HTML5，尽管有验证器指出这是一个无法验证的属性，但在HTML4当中使用是不会造成任何问题的）。但浏览器并不知道它是什么意思，所以你需要激活Knockout来使其生效。 12345// 激活对象ko.applyBindings(people);// 设置使用data-bind属性的HTML元素或者容器ko.applyBindings(people, $('#people')); 数据绑定 1&lt;span data-bind=\"text:name\"&gt;","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"基于Fatfree和Knockout的前后端分离的开发模式(1)","date":"2017-09-18T04:23:28.000Z","path":"基于Fatfree和Knockout的前后端分离的开发模式（1）/","text":"近几年，与前端相关的技术变革的很快，从Ajax技术的兴起，到现在比较流行的三大前端框架(Angular.js、react.js、vue.js)，从MVC到MVVM到设计模式，前端的技术与思想有了革命性的发展。 近期在整理技术栈时，觉得这个方法是一套成熟的开发模式，虽然可能有点过时，但是还是整理出来分享给大家，相互间学习。 1 设计模式1.1 MVC MVC设计模式是指模型—视图—控制器三层的设计框架，Model主要进行数据的操作，View主要完成UI界面的绘制和与用户的交互，Controller主要是从视图里面读取数据，并像模型发送数据写入到数据库。 mvc设计模式是最常见的设计模式，在这不进行说明，在下面的MVVM章节针对这个开发模式进行详细的说明。 1.2 MVVM MVVM（Model-View-ViewModel)是在MVC(Model-View-Control)模式之后引出的新的开发模式，他与MVC模式一样用于把视图（界面）和数据进行解耦，不同的是采用ViewModel来完成数据与视图的双向绑定，通过自动化的方式承担大部分数据工作，来解决由于界面复杂化和快速迭代带来的问题。 MVVM是MVC设计模式的升级，更多的是前端来提MVVM的设计模式的一个概念，前端通过Ajax技术来获取数据。API提供的数据的Json的格式，然后通过Model模块将数据进行解析，ViewModel将View与Model进行绑定，用户访问View。 后端还是会采用传统的MVC的设计模式，API提供Json数据格式的数据。同时在该开发流程中，页面的路由和API的路由都是通过后端来控制的，这跟目前比较流行的前端路由存在着差别。 2 后端2.1 Web框架在这个开发模式中，使用的Web框架为Fatfree，这是一个轻量的Web框架，但是提供的功能比较齐全。包括了路由模块，数据库模块，支持多种数据库，包括Mysql，Sqlite，MongoDB等等。 2.1.1 路由Fatfree有两种路由的写法，一种是写到配置文件，一种是直接写到程序的入口函数中。 1234567$f3 = require('path/to/base.php');$f3 = route('GET /', function()&#123; echo 'hello,world!'; &#125;);$f3 -&gt; run; 这个程序是一个最基本的Hello World的程序，就是将路由写到了程序入口的函数中。通过GET的方法来请求／路由，得到一个’hello,world!’的界面。 还有一种通过配置文件的方式来定义路由： 1$f3-&gt;config('app/config/routes.ini'); 然后在配置文件添加路由： 12[routes]GET / = IndexController-&gt;index 通过GET的方法来请求/路由，通过IndexController类里面的index方法来返回结果。 2.1.2 数据库 对象关系映射（英语：(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换[1] 。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 fatfree提供了\\DB\\SQL\\Mapper的ORM类，里面包含了数据库基本的增删改查，能够提供基本的功能。 链接数据库： 1$mapper = new \\DB\\SQL\\Mapper(\\DB\\SQL $db, string $table [, array|string $fields = NULL [, int $ttl = 60 ]] ) 如果你想把其写成Model库，可以按照下面的方法写： 12345678910$f3-&gt;set('DB',new DB\\SQL('sqlite:db/database.sqlite'));class User extends \\DB\\SQL\\Mapper &#123; public function __construct() &#123; parent::__construct( \\Base::instance()-&gt;get('DB'), 'users' ); &#125;&#125;$user = new User();$user-&gt;load('id = 1'); 查寻数据： 123456//load()方法$user-&gt;load(array(\"id\",1));//findone()方法$user-&gt;findone(array(\"id\",1));//find()方法$user-&gt;find(array(\"id\",1)) 添加数据或修改数据： 123456789$user = new User();$user-&gt;id = 2;$user-&gt;save();// save()函数比较智能，若是数据存在则会对数据进行修改$user = new User();$user-&gt;load('id = 1');$user-&gt;id = 2;$user-&gt;save(); 删除数据： 123$user = new User();$user-&gt;load('id = 1');$user-&gt;erase(); 2.1.3 PHP包管理工具 Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 “packages” 和 “libraries”，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。 Composer的具体安装和使用在这里就不做具体的说明了，需要学习的话网上有很多的教程。 composer.json可以如下进行配置： 12345678910111213&#123; \"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" &#125; &#125;, \"require\":&#123; \"robmorgan/phinx\":\"*\", \"bcosca/fatfree\": \"3.3.0\" &#125;, \"require-dev\": &#123;&#125;&#125; 里面的Phinx是数据库迁移的工具，fatfree是我们使用的web框架。 1234# composer没有全局安装php composer.phar install# composer全局安装composer install 安装成功后会自动生成vendor目录，文件目录的组织方式是vendor／项目所有人名／项目名。例如：vendor/robmorgan/phinx。 2.1.4 数据库迁移工具数据库迁移工具的目的主要是使得开发人员在开发环境和线上环境进行统一，减少了程序员手动对数据库进行修改。 在这个开发模式中，我们选择了Phinx作为数据库迁移的工具。通过composer我们已经把phinx安装成功了。 12# 初始化项目，会在文件中添加一个db/migrations文件夹php vendor/bin/phinx init 添加表 1php vendor/bin/phinx create MyNewMigration 执行上面的命令会在生成的文件目录下面新建一个YYYYMMDDHHMMSS_my_new_migration.php文件。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpuse Phinx\\Migration\\AbstractMigration;class CreateUserLoginsTable extends AbstractMigration&#123; /** * Change Method. * * More information on this method is available here: * http://docs.phinx.org/en/latest/migrations.html#the-change-method * * Uncomment this method if you would like to use it. */ public function change() &#123; $table = $this-&gt;table('user_logins'); $table-&gt;addColumn('user_id', 'integer') -&gt;addColumn('created', 'datetime') -&gt;create(); &#125; /** * Migrate Up. */ public function up() &#123; $this-&gt;execute(\"CREATE TABLE `users` (`name` varchar(64) NOT NULL DEFAULT '',`passwords` varchar(255) NOT NULL DEFAULT '',`id` INT NOT NULL auto_increment PRIMARY KEY,`leave` INT NOT NULL DEFAULT 1) ENGINE=InnoDB DEFAULT CHARSET=utf8;\"); &#125; /** * Migrate Down. */ public function down() &#123; $this-&gt;execute(\"DROP TABLE `users`;\"); &#125;&#125; 生成的文件中可以包含三个方法，一个是新建，一个是修改，一个是删除。方法里面可以使用ORM的方法，但是也可以写SQL语句。 命令： 12345# 迁移phinx migrate#回退 phinx rollback -e development -t 20120103083322 配置： 在init后，phinx在生成目录的时间同时也会生成一个phinx.yml文件，里面可以把数据库的配置文件写到里面。 12345678910111213paths: migrations: %%PHINX_CONFIG_DIR%%/db/migrationsenvironments: default_migration_table: phinxlog default_database: development development: adapter: mysql host: 127.0.0.1 name: user: pass: port: 3306 charset: utf8","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"go语言中使用反射函数代替switch语法","date":"2017-07-30T03:49:45.000Z","path":"go语言中使用反射函数代替switch语法/","text":"近期在公司实习，参与了公司的一个分布式的应用服务系统。系统采用Golang语言作为系统的开发语言，在开发过程中采用了Go语言的反射函数的特性来取代了以前常使用的switch语法。 switch-case是一种多种选择的语法，其本质与if-else方法差不多，都是通过判断条件来执行不同的方法。而Go提供了一种机制在运行时更新变量和检查它们的值，调用它们的方法，和它们支持的内在操作，但是在编译时并不知道这些变量的类型。这种机制被称为反射，反射也可以让我们将类型本身作为第一类的值类型处理。 Web应用路由问题在我们编写Web应用过程中，常常会遇到一个路由需要对应一个方法，我们会选择使用switch的方法来进行路由的匹配，若是路由匹配成功，我们会调用一个方法，这种方法能够很简便的完成我们的工作，也便于程序员在编写代码过程中厘清思路。 问题： 在一个URL的路由中，我们在request中通过cmd的参数来对应一个方法，这样我们要如何根据一个cmd对应一个方法？ 可能针对这个问题有人会说，我们为什么不把cmd放到URL里面，这样的话就是一个方法对应一个路由，而且大多数的Web框架会通过回调函数来进行函数调用，针对于这个问题，我只能说大部分的都是将cmd放到http的request里面的，具体的好处可能就是减少了对API的监管，以及当路由比较多的时间能够减少麻烦吧。 用switch方法实现： 123456789cmd := this.GetString(\"cmd\")switch cmd&#123; case \"ls\": ls() case \"cd\": cd() default: fmt.Println(\"cmd method missing\")&#125; 上述的方法先通过URL的参数获取到cmd，然后通过cmd来调用相对应的方法。在传统的MVC的设计模式中，需要在Controller中添加switch方法，同时需要在Model中实现相对应的方法，总计修改了2个文件。 go语言反射函数reflect包在reflect包中，主要通过Typeof()和Valueof()两个方法来实现反射。两个方法相互结合，能够反射出被反射函数的全部信息。 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"reflect\")type Ref struct &#123; id int name string&#125;func (ref *Ref)GetName()&#123; fmt.Println(\"getName()函数\")&#125;func (ref *Ref)GetNameById()&#123; fmt.Println(\"getNameById()函数\")&#125;func main()&#123; t := reflect.TypeOf(&amp;Ref&#123;&#125;) v := reflect.ValueOf(new(Ref)) fmt.Println(t) fmt.Println(v) for i:= 0; i&lt; t.NumMethod();i++&#123; fmt.Println(t.Method(i).Name) v.Method(i).Call(nil) &#125;&#125; TypeOf()TypeOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Type类型。 在上面的示例中，通过Method().Name能够反射其方法的函数名。 常用的方法： func (t *rtype)String() string func (t *rtype)Name() string func (t *rtype)Kind() reflect.kind func (t *rtype)Method(int) reflect.Method func (t *rtype)Elem() reflect.Type func (t *rtype)In(int) reflect.Type ValueOf()ValueOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Value类型。 在上面的示例中，通过Method().Call()能够反射出其函数并执行。 常用的方法： func (v Value)String() string func (v Value)Elem() reflect.Value func (v Value)Method(int) reflect.Value func (v Value)Call(in []Value) (r []Value) 反射的实现过程由于有反射的存在，因此在传统的MVC的设计模式中，当我们添加服务时，不需要修改Controller端的代码，Controller只需要维持一个map的表，里面的就来存储需要被反射的models。 123456789101112131415161718192021222324252627282930package server import( \"reflect\" \"fmt\")// ReServer 来保存map的结构体type ReServer struct &#123; m map[string]interface&#123;&#125;&#125;// RegisterService 注册服务func (this *ReServer)RegisterService(service interface&#123;&#125;)(err error)&#123; serviceType := reflect.TypeOf(service).Elem() ServiceName := serviceType.Name() if _,ok := this.m[ServiceName] if ok &#123; fmt.Println(\"service has been registered\") &#125;else&#123; this.m[ServiceName] = service &#125; return&#125;// Start 服务启动func (this *ReServer)Start()&#123; for k,v := range this.m &#123; // 里面根据业务逻辑执行想要的方法 &#125;&#125; 在上诉的例子中，通过对services的服务注册，就能够通过Start()函数发现服务，并且根据业务来实现自己的代码。 1234567891011121314151617181920package mainimport ( \"server\")type Server struct &#123;&#125;func (server *Server)funOne()&#123; fmt.Println(\"Server FunOne\")&#125; func main()&#123; reServer := &amp;server.ReServer&#123; m: make(map[string]interface&#123;&#125;) &#125; err := reServer.RegisterService(new(Server)) reServer.Start()&#125; 因此在我们主函数中，导入封装好的包，只需要注册一个结构体，就能够将自己的方法反射出来实现。 对应上面的Web的路由问题，我们将Controller进行封装，然后将Model进行反射，当我们业务增加时，我们在Model里面添加就可以了，不需要修改Controller。","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"openfalon监控配置","date":"2017-05-16T02:27:29.000Z","path":"openfalon监控配置/","text":"最进在看《docker 容器与容器云 第2版》，但是对于运维的一些知识还是不够了解，在同学的推荐下，尝试配置openfalon监控，监控自己写的软件，为以后需要开发的项目积累一点经验。 Open-falcon是小米运维团队从互联网公司的需求出发，根据多年的运维经验，结合SRE、SA、DEVS的使用经验和反馈，开发的一套面向互联网的企业级开源监控产品。 准备工作Open-falcon的开发语言是golang语言，创始人秦晓辉在谈为何选择golang语言时也有一定的说明：open-falcon编写的整个脑洞历程 源码安装123456#查看go语言环境go version#若没有安装go语言环境需要安装go语言sudo apt install golangecho \"export GOPATH=~/workspaces/go\" &gt;&gt; ~/.bashrcsource ~/.bashrc 安装Redis和mysql 12sudo apt install redis-serversudo apt install mysql-server 安装文件下载已经安装位置确定 123mkdir -p $GOPATH/src/github.com/open-falconcd $GOPATH/src/github.com/open-falcongit clone https://github.com/open-falcon/falcon-plus.git 导入数据库 123456cd $GOPATH/src/github.com/open-falcon/falcon-plus/scripts/mysql/db_schema/mysql -h 127.0.0.1 -u root -p &lt; uic-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; portal-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; graph-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; dashboard-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; alarms-db-schema.sql 安装，安装成功后会生成一个压缩包 123make allmake agentmake pack 解包和建立文件目录 1234export WorkDir=\"$HOME/open-falcon\"mkdir -p $WorkDirtar -xzvf open-falcon-vx.x.x.tar.gz -C $WorkDircd $WorkDir 数据库连接的配置格式是: username:password@tcp(path:port)/xxxx 安装web监控端dashboard下载dashboard源码 123export WorkDir=\"$HOME/open-falcon\"cd $WorkDirgit clone https://github.com/open-falcon/dashboard.git 下载安装依赖 12345678910sudo suapt-get install -y python-virtualenvapt-get install -y slapd ldap-utilsapt-get install -y libmysqld-devapt-get install -y build-essentialapt-get install -y python-dev libldap2-dev libsasl2-dev libssl-devcd dashboardsudo virtualenv ./env./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple 修改配置，dashboard的配置文件为config.py 123#添加数据库密码，默认为空PORTAL_DB_PASS = os.environ.get(\"PORTAL_DB_PASS\",\"123456\")ALARM_DB_PASS = os.environ.get(\"ALARM_DB_PASS\",\"123456\") 启动 1./control start","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"nodejs项目安装与部署","date":"2017-04-14T01:50:44.000Z","path":"nodejs项目安装与部署/","text":"nodejs安装： 1brew install node Backend后端代码部署nodejs后端web框架选择express Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 安装步骤： 1npm install -g express -g参数说明express是全局安装，express在4.0以后就将express的命令行工具分离出来了，需要独立安装。 1npm install -g express-generator 安装成功后就可以部署项目了，express主要是后端程序 1express -e backend 安装依赖 1npm install 启动后台程序 1npm start frontend前端代码部署项目前端框架选择vue Vue.js 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 1、安装步骤 1npm install -g vue 同样，vue的命令行工具也要单独安装： 12345678# 全局安装命令行工具npm install -g vue-cli# 创建项目vue init webpack frontend# 安装依赖并启动cd frontendnpm install npm run dev","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"王者荣耀挂机脚本初探（1）","date":"2017-04-07T07:08:22.000Z","path":"王者荣耀挂机脚本初探（1）/","text":"​ 最近和同学一起准备写一个王者荣耀的挂机程序，因此写一个文档把实验过程和实验过程中遇到的问题进行记录。 ​ 目前选择的是安卓微信平台，通过微信扫码登陆。 虚拟机的选择​ 在腾讯的王者荣耀的官方网站上有推荐的虚拟机，在尝试了不同的虚拟机后选择了逍遥游模拟器，优点：可以模拟按键、能够多开程序。 虚拟机端口查找​ 在选择好了虚拟机后，要尝试用adb连接到开的程序，但是现在是不知道程序运行的端口，因此要查询到程序运行的端口。 ​ 测试平台选择了windows10，因此在cmd命令行工具中输入命令，使用netstat -0命令扫描全部的端口。 在没有运行模拟器时发现端口，便于跟模拟器运行后的端口进行对比。运行模拟器： 根据上面的对比，大概猜测端口为21501、21503、21505、32799、32804、32807，尝试使用abd全部连接，然后根据连接情况进行判断。 可以进一步判断端口为21501、21503、21505。然后查看当前的运行的模拟器： 已经可以判断端口为21503。 模拟器多开端口查询·跟上诉的步骤相同： 可以观察出大致每添加一个模拟器，端口号增加10。 简单通过adb shell连接控制游戏 可以发现王者里面的英雄动了，第一步成功。 遇到问题 连接模拟器过多，解决方法：打开任务管理器，把adb.exe进程结束，然后重新连接。","tags":[{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"Hexo搭件个人博客","date":"2017-04-02T06:10:25.000Z","path":"Hexo搭件个人博客/","text":"​ 作为一个程序员，一开始还是希望有自己的个人博客，高中时，一个同学给了一个二级域名，然后让我自己来做这个博客，好像是用的WordPress，但是高中时期基本上不了解计算机技术，最终还是不了了之，后面大学买了属于自己的域名和服务器，里面搭件了两个博客，由于服务器是外网的，后台访问速度很慢，也就没有使用，因此选择了hexo和coding.net来搭件自己的博客。 hexo下载安装安装命令 ，-g参数是全局安装 1npm install -g hexo 在Coding.net上创建项目，并且克隆到本地 1git clone https://git.coding.net/flytutu/blog.git 初始化hexo并且安装依赖 12hexo initnpm install 本地预览hexo博客 12hexo ghexo s 然后在浏览器上面访问http://localhost:4000，可以看到hexo在浏览器上面的样子 hexo上传代码部署本地文件到coding.net，打开根目录_config.yml文件，在文件末尾添加： 1234deploy: type: gitrepository: https://git.coding.net/flytutu/blog.gitbranch: master 然后可以上传代码， 1hexo d 若上传报错，需要下载hexo-deployer-git模块 1npm install hexo-deployer-git --save Coding.net里面打开pages服务，然后将自己的域名绑定 域名绑定 新建界面，然后在文件source/_posts里面看到文件，然后可以修改 1hexo new \"文件名称\"","tags":[{"name":"闲谈","slug":"闲谈","permalink":"http://yoursite.com/tags/闲谈/"}]}]