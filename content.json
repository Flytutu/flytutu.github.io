[{"title":"go语言中使用反射函数代替switch语法","date":"2017-07-30T03:49:45.000Z","path":"go语言中使用反射函数代替switch语法/","text":"近期在公司实习，参与了公司的一个分布式的应用服务系统。系统采用Golang语言作为系统的开发语言，在开发过程中采用了Go语言的反射函数的特性来取代了以前常使用的switch语法。 switch-case是一种多种选择的语法，其本质与if-else方法差不多，都是通过判断条件来执行不同的方法。而Go提供了一种机制在运行时更新变量和检查它们的值，调用它们的方法，和它们支持的内在操作，但是在编译时并不知道这些变量的类型。这种机制被称为反射，反射也可以让我们将类型本身作为第一类的值类型处理。 Web应用路由问题在我们编写Web应用过程中，常常会遇到一个路由需要对应一个方法，我们会选择使用switch的方法来进行路由的匹配，若是路由匹配成功，我们会调用一个方法，这种方法能够很简便的完成我们的工作，也便于程序员在编写代码过程中厘清思路。 问题： 在一个URL的路由中，我们在request中通过cmd的参数来对应一个方法，这样我们要如何根据一个cmd对应一个方法？ 可能针对这个问题有人会说，我们为什么不把cmd放到URL里面，这样的话就是一个方法对应一个路由，而且大多数的Web框架会通过回调函数来进行函数调用，针对于这个问题，我只能说大部分的云厂商是将cmd放到http的request里面的，具体的好处可能就是减少了对API的监管吧。 用switch方法实现： 123456789cmd := this.GetString(\"cmd\")switch cmd&#123; case \"ls\": ls() case \"cd\": cd() default: fmt.Println(\"cmd method missing\")&#125; 上述的方法先通过URL的参数获取到cmd，然后通过cmd来调用相对应的方法。在传统的MVC的设计模式中，需要在Controller中添加switch方法，同时需要在Model中实现相对应的方法，总计修改了2个文件。 go语言反射函数reflect包在reflect包中，主要通过Typeof()和Valueof()两个方法来实现反射。两个方法相互结合，能够反射出被反射函数的全部信息。 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"reflect\")type Ref struct &#123; id int name string&#125;func (ref *Ref)GetName()&#123; fmt.Println(\"getName()函数\")&#125;func (ref *Ref)GetNameById()&#123; fmt.Println(\"getNameById()函数\")&#125;func main()&#123; t := reflect.TypeOf(&amp;Ref&#123;&#125;) v := reflect.ValueOf(new(Ref)) fmt.Println(t) fmt.Println(v) for i:= 0; i&lt; t.NumMethod();i++&#123; fmt.Println(t.Method(i).Name) v.Method(i).Call(nil) &#125;&#125; TypeOf()TypeOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Type类型。 在上面的示例中，通过Method().Name能够反射其方法的函数名。 常用的方法： func (t *rtype)String() string func (t *rtype)Name() string func (t *rtype)Kind() reflect.kind func (t *rtype)Method(int) reflect.Method func (t *rtype)Elem() reflect.Type func (t *rtype)In(int) reflect.Type ValueOf()ValueOf()函数主要是打印出被反射函数的类型，其返回结果是reflect.Value类型。 在上面的示例中，通过Method().Call()能够反射出其函数并执行。 常用的方法： func (v Value)String() string func (v Value)Elem() reflect.Value func (v Value)Method(int) reflect.Value func (v Value)Call(in []Value) (r []Value) 反射的实现过程由于有反射的存在，因此在传统的MVC的设计模式中，当我们添加服务时，不需要修改Controller端的代码，Controller只需要维持一个map的表，里面的就来存储需要被反射的models。 123456789101112131415161718192021222324252627282930package server import( \"reflect\" \"fmt\")// ReServer 来保存map的结构体type ReServer struct &#123; m map[string]interface&#123;&#125;&#125;// RegisterService 注册服务func (this *ReServer)RegisterService(service interface&#123;&#125;)(err error)&#123; serviceType := reflect.TypeOf(service).Elem() ServiceName := serviceType.Name() if _,ok := this.m[ServiceName] if ok &#123; fmt.Println(\"service has been registered\") &#125;else&#123; this.m[ServiceName] = service &#125; return&#125;// Start 服务启动func (this *ReServer)Start()&#123; for k,v := range this.m &#123; // 里面根据业务逻辑执行想要的方法 &#125;&#125; 在上诉的例子中，通过对services的服务注册，就能够通过Start()函数发现服务，并且根据业务来实现自己的代码。 1234567891011121314151617181920package mainimport ( \"server\")type Server struct &#123;&#125;func (server *Server)funOne()&#123; fmt.Println(\"Server FunOne\")&#125; func main()&#123; reServer := &amp;server.ReServer&#123; m: make(map[string]interface&#123;&#125;) &#125; err := reServer.RegisterService(new(Server)) reServer.Start()&#125; 因此在我们主函数中，导入封装好的包，只需要注册一个结构体，就能够将自己的方法反射出来实现。 对应上面的Web的路由问题，我们将Controller进行封装，然后将Model进行反射，当我们业务增加时，我们在Model里面添加就可以了，不需要修改Controller。","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"openfalon监控配置","date":"2017-05-16T02:27:29.000Z","path":"openfalon监控配置/","text":"最进在看《docker 容器与容器云 第2版》，但是对于运维的一些知识还是不够了解，在同学的推荐下，尝试配置openfalon监控，监控自己写的软件，为以后需要开发的项目积累一点经验。 Open-falcon是小米运维团队从互联网公司的需求出发，根据多年的运维经验，结合SRE、SA、DEVS的使用经验和反馈，开发的一套面向互联网的企业级开源监控产品。 准备工作Open-falcon的开发语言是golang语言，创始人秦晓辉在谈为何选择golang语言时也有一定的说明：open-falcon编写的整个脑洞历程 源码安装123456#查看go语言环境go version#若没有安装go语言环境需要安装go语言sudo apt install golangecho &quot;export GOPATH=~/workspaces/go&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 安装Redis和mysql 12sudo apt install redis-serversudo apt install mysql-server 安装文件下载已经安装位置确定 123mkdir -p $GOPATH/src/github.com/open-falconcd $GOPATH/src/github.com/open-falcongit clone https://github.com/open-falcon/falcon-plus.git 导入数据库 123456cd $GOPATH/src/github.com/open-falcon/falcon-plus/scripts/mysql/db_schema/mysql -h 127.0.0.1 -u root -p &lt; uic-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; portal-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; graph-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; dashboard-db-schema.sqlmysql -h 127.0.0.1 -u root -p &lt; alarms-db-schema.sql 安装，安装成功后会生成一个压缩包 123make allmake agentmake pack 解包和建立文件目录 1234export WorkDir=&quot;$HOME/open-falcon&quot;mkdir -p $WorkDirtar -xzvf open-falcon-vx.x.x.tar.gz -C $WorkDircd $WorkDir 数据库连接的配置格式是: username:password@tcp(path:port)/xxxx 安装web监控端dashboard下载dashboard源码 123export WorkDir=&quot;$HOME/open-falcon&quot;cd $WorkDirgit clone https://github.com/open-falcon/dashboard.git 下载安装依赖 12345678910sudo suapt-get install -y python-virtualenvapt-get install -y slapd ldap-utilsapt-get install -y libmysqld-devapt-get install -y build-essentialapt-get install -y python-dev libldap2-dev libsasl2-dev libssl-devcd dashboardsudo virtualenv ./env./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple 修改配置，dashboard的配置文件为config.py 123#添加数据库密码，默认为空PORTAL_DB_PASS = os.environ.get(\"PORTAL_DB_PASS\",\"123456\")ALARM_DB_PASS = os.environ.get(\"ALARM_DB_PASS\",\"123456\") 启动 1./control start","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"nodejs项目安装与部署","date":"2017-04-14T01:50:44.000Z","path":"nodejs项目安装与部署/","text":"nodejs安装： 1brew install node Backend后端代码部署nodejs后端web框架选择express Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 安装步骤： 1npm install -g express -g参数说明express是全局安装，express在4.0以后就将express的命令行工具分离出来了，需要独立安装。 1npm install -g express-generator 安装成功后就可以部署项目了，express主要是后端程序 1express -e backend 安装依赖 1npm install 启动后台程序 1npm start frontend前端代码部署项目前端框架选择vue Vue.js 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 1、安装步骤 1npm install -g vue 同样，vue的命令行工具也要单独安装： 12345678# 全局安装命令行工具npm install -g vue-cli# 创建项目vue init webpack frontend# 安装依赖并启动cd frontendnpm install npm run dev","tags":[{"name":"code","slug":"code","permalink":"http://yoursite.com/tags/code/"}]},{"title":"王者荣耀挂机脚本初探（1）","date":"2017-04-07T07:08:22.000Z","path":"王者荣耀挂机脚本初探（1）/","text":"​ 最近和同学一起准备写一个王者荣耀的挂机程序，因此写一个文档把实验过程和实验过程中遇到的问题进行记录。 ​ 目前选择的是安卓微信平台，通过微信扫码登陆。 虚拟机的选择​ 在腾讯的王者荣耀的官方网站上有推荐的虚拟机，在尝试了不同的虚拟机后选择了逍遥游模拟器，优点：可以模拟按键、能够多开程序。 虚拟机端口查找​ 在选择好了虚拟机后，要尝试用adb连接到开的程序，但是现在是不知道程序运行的端口，因此要查询到程序运行的端口。 ​ 测试平台选择了windows10，因此在cmd命令行工具中输入命令，使用netstat -0命令扫描全部的端口。 在没有运行模拟器时发现端口，便于跟模拟器运行后的端口进行对比。运行模拟器： 根据上面的对比，大概猜测端口为21501、21503、21505、32799、32804、32807，尝试使用abd全部连接，然后根据连接情况进行判断。 可以进一步判断端口为21501、21503、21505。然后查看当前的运行的模拟器： 已经可以判断端口为21503。 模拟器多开端口查询·跟上诉的步骤相同： 可以观察出大致每添加一个模拟器，端口号增加10。 简单通过adb shell连接控制游戏 可以发现王者里面的英雄动了，第一步成功。 遇到问题 连接模拟器过多，解决方法：打开任务管理器，把adb.exe进程结束，然后重新连接。","tags":[{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"Hexo搭件个人博客","date":"2017-04-02T06:10:25.000Z","path":"Hexo搭件个人博客/","text":"​ 作为一个程序员，一开始还是希望有自己的个人博客，高中时，一个同学给了一个二级域名，然后让我自己来做这个博客，好像是用的WordPress，但是高中时期基本上不了解计算机技术，最终还是不了了之，后面大学买了属于自己的域名和服务器，里面搭件了两个博客，由于服务器是外网的，后台访问速度很慢，也就没有使用，因此选择了hexo和coding.net来搭件自己的博客。 hexo下载安装安装命令 ，-g参数是全局安装 1npm install -g hexo 在Coding.net上创建项目，并且克隆到本地 1git clone https://git.coding.net/flytutu/blog.git 初始化hexo并且安装依赖 12hexo initnpm install 本地预览hexo博客 12hexo ghexo s 然后在浏览器上面访问http://localhost:4000，可以看到hexo在浏览器上面的样子 hexo上传代码部署本地文件到coding.net，打开根目录_config.yml文件，在文件末尾添加： 1234deploy: type: gitrepository: https://git.coding.net/flytutu/blog.gitbranch: master 然后可以上传代码， 1hexo d 若上传报错，需要下载hexo-deployer-git模块 1npm install hexo-deployer-git --save Coding.net里面打开pages服务，然后将自己的域名绑定 域名绑定 新建界面，然后在文件source/_posts里面看到文件，然后可以修改 1hexo new &quot;文件名称&quot;","tags":[{"name":"闲谈","slug":"闲谈","permalink":"http://yoursite.com/tags/闲谈/"}]}]